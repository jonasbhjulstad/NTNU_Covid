/*
 * Vulkan Example - imGui (https://github.com/ocornut/imgui)
 *
 * Copyright (C) 2017 by Sascha Willems - www.saschawillems.de
 *
 * This code is licensed under the MIT license (MIT) (http://opensource.org/licenses/MIT)
 */

#include "vulkanexamplebase.h"
#include "VulkanglTFModel.h"
#include <random>
#include <chrono>
#define ENABLE_VALIDATION true
#include "computeBasic.hpp"

// ----------------------------------------------------------------------------
// VulkanExample
// ----------------------------------------------------------------------------

#ifdef WIN32
const std::string assetPath = "C:\\Users\\jonas\\Documents\\Vulkan\\examples\\imgui\\data\\";
const std::string shadersPath = assetPath + "shaders\\";
const std::string computeShadersPath = assetPath + "computeShaders";
const std::string modelPath = assetPath + "models\\";
const std::string texturePath = assetPath + "textures\\";
#else
const std::string assetPath = "/home/deb/Documents/Vulkan/examples/imgui/data/";
const std::string shadersPath = assetPath + "shaders/";
const std::string computeShadersPath = assetPath + "computeShaders";
const std::string modelPath = assetPath + "models/";
const std::string texturePath = assetPath + "textures/";
#endif


const uint32_t N_PARTICLES = 255;

struct SIR_State
{
	
};


class VulkanExample : public VulkanExampleBase
{
	void render(){};
};

VkDescriptorPool setupDescriptorPool(VkDevice device)
{
	const uint32_t N_GLTF_BASIC_INSTANCE_TYPES = 2;
	std::vector<VkDescriptorPoolSize> poolSizes =
		{
			vks::initializers::descriptorPoolSize(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1),
			vks::initializers::descriptorPoolSize(VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1)
		};

	VkDescriptorPool descriptorPool;
	VkDescriptorPoolCreateInfo descriptorPoolInfo = vks::initializers::descriptorPoolCreateInfo(poolSizes, 2);
	VK_CHECK_RESULT(vkCreateDescriptorPool(device, &descriptorPoolInfo, nullptr, &descriptorPool));

	return descriptorPool;
}

std::vector<SIR_State> genereateInitialState(uint32_t N_particles)
{
	std::vector<SIR_State> initialStates(N_particles);
	for (auto& initialState: initialStates)
	{
	}
}

using namespace BasicCompute;
int main()
{
	auto vulkanExample = new VulkanExample();
	vulkanExample->initVulkan();
	vks::VulkanDevice* vulkanDevice = vulkanExample->vulkanDevice;
	VkDevice device = vulkanDevice->logicalDevice;

	vks::Buffer storageBuffer;
	vks::Buffer uniformBuffer;


	BasicComputeParams p;
	p.computeShaderPath = computeShadersPath + "SIR.comp.spv";
	p.descriptorPool = setupDescriptorPool(device);
	p.N_particles = 255;
	p.pipelineCache = nullptr;
	p.queueFamilyIndex = vulkanDevice->queueFamilyIndices.compute;
	p.storageBuffer = &storageBuffer;
	p.uniformBuffer = &uniformBuffer;

	auto BC_data = prepareBasicCompute();
	// vulkanExample->setupWindow();
	// vulkanExample->prepare();
}